// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MCManagementClient is the client API for MCManagement service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MCManagementClient interface {
	GetPlayerCount(ctx context.Context, in *GetPlayerCountRequest, opts ...grpc.CallOption) (*GetPlayerCountResponse, error)
	SubscribePlayerCount(ctx context.Context, in *SubscribePlayerCountRequest, opts ...grpc.CallOption) (MCManagement_SubscribePlayerCountClient, error)
	UpdateWhitelist(ctx context.Context, in *UpdateWhitelistRequest, opts ...grpc.CallOption) (*UpdateWhitelistResponse, error)
	SubscribePlayerEvent(ctx context.Context, in *SubscribePlayerEventRequest, opts ...grpc.CallOption) (MCManagement_SubscribePlayerEventClient, error)
	GetResourceConsumption(ctx context.Context, in *GetResourceConsumptionRequest, opts ...grpc.CallOption) (*GetResourceConsumptionResponse, error)
	SubscribeResourceConsumptionEvent(ctx context.Context, in *SubscribeResourceConsumptionEventRequest, opts ...grpc.CallOption) (MCManagement_SubscribeResourceConsumptionEventClient, error)
	SubscribeHeartbeat(ctx context.Context, in *SubscribeHeartbeatRequest, opts ...grpc.CallOption) (MCManagement_SubscribeHeartbeatClient, error)
}

type mCManagementClient struct {
	cc grpc.ClientConnInterface
}

func NewMCManagementClient(cc grpc.ClientConnInterface) MCManagementClient {
	return &mCManagementClient{cc}
}

func (c *mCManagementClient) GetPlayerCount(ctx context.Context, in *GetPlayerCountRequest, opts ...grpc.CallOption) (*GetPlayerCountResponse, error) {
	out := new(GetPlayerCountResponse)
	err := c.cc.Invoke(ctx, "/MCManagement/GetPlayerCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCManagementClient) SubscribePlayerCount(ctx context.Context, in *SubscribePlayerCountRequest, opts ...grpc.CallOption) (MCManagement_SubscribePlayerCountClient, error) {
	stream, err := c.cc.NewStream(ctx, &MCManagement_ServiceDesc.Streams[0], "/MCManagement/SubscribePlayerCount", opts...)
	if err != nil {
		return nil, err
	}
	x := &mCManagementSubscribePlayerCountClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MCManagement_SubscribePlayerCountClient interface {
	Recv() (*SubscribePlayerCountResponse, error)
	grpc.ClientStream
}

type mCManagementSubscribePlayerCountClient struct {
	grpc.ClientStream
}

func (x *mCManagementSubscribePlayerCountClient) Recv() (*SubscribePlayerCountResponse, error) {
	m := new(SubscribePlayerCountResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mCManagementClient) UpdateWhitelist(ctx context.Context, in *UpdateWhitelistRequest, opts ...grpc.CallOption) (*UpdateWhitelistResponse, error) {
	out := new(UpdateWhitelistResponse)
	err := c.cc.Invoke(ctx, "/MCManagement/UpdateWhitelist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCManagementClient) SubscribePlayerEvent(ctx context.Context, in *SubscribePlayerEventRequest, opts ...grpc.CallOption) (MCManagement_SubscribePlayerEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &MCManagement_ServiceDesc.Streams[1], "/MCManagement/SubscribePlayerEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &mCManagementSubscribePlayerEventClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MCManagement_SubscribePlayerEventClient interface {
	Recv() (*SubscribePlayerEventResponse, error)
	grpc.ClientStream
}

type mCManagementSubscribePlayerEventClient struct {
	grpc.ClientStream
}

func (x *mCManagementSubscribePlayerEventClient) Recv() (*SubscribePlayerEventResponse, error) {
	m := new(SubscribePlayerEventResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mCManagementClient) GetResourceConsumption(ctx context.Context, in *GetResourceConsumptionRequest, opts ...grpc.CallOption) (*GetResourceConsumptionResponse, error) {
	out := new(GetResourceConsumptionResponse)
	err := c.cc.Invoke(ctx, "/MCManagement/GetResourceConsumption", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCManagementClient) SubscribeResourceConsumptionEvent(ctx context.Context, in *SubscribeResourceConsumptionEventRequest, opts ...grpc.CallOption) (MCManagement_SubscribeResourceConsumptionEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &MCManagement_ServiceDesc.Streams[2], "/MCManagement/SubscribeResourceConsumptionEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &mCManagementSubscribeResourceConsumptionEventClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MCManagement_SubscribeResourceConsumptionEventClient interface {
	Recv() (*SubscribeResourceConsumptionEventReponse, error)
	grpc.ClientStream
}

type mCManagementSubscribeResourceConsumptionEventClient struct {
	grpc.ClientStream
}

func (x *mCManagementSubscribeResourceConsumptionEventClient) Recv() (*SubscribeResourceConsumptionEventReponse, error) {
	m := new(SubscribeResourceConsumptionEventReponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mCManagementClient) SubscribeHeartbeat(ctx context.Context, in *SubscribeHeartbeatRequest, opts ...grpc.CallOption) (MCManagement_SubscribeHeartbeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &MCManagement_ServiceDesc.Streams[3], "/MCManagement/SubscribeHeartbeat", opts...)
	if err != nil {
		return nil, err
	}
	x := &mCManagementSubscribeHeartbeatClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MCManagement_SubscribeHeartbeatClient interface {
	Recv() (*SubscribeHeartbeatResponse, error)
	grpc.ClientStream
}

type mCManagementSubscribeHeartbeatClient struct {
	grpc.ClientStream
}

func (x *mCManagementSubscribeHeartbeatClient) Recv() (*SubscribeHeartbeatResponse, error) {
	m := new(SubscribeHeartbeatResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MCManagementServer is the server API for MCManagement service.
// All implementations must embed UnimplementedMCManagementServer
// for forward compatibility
type MCManagementServer interface {
	GetPlayerCount(context.Context, *GetPlayerCountRequest) (*GetPlayerCountResponse, error)
	SubscribePlayerCount(*SubscribePlayerCountRequest, MCManagement_SubscribePlayerCountServer) error
	UpdateWhitelist(context.Context, *UpdateWhitelistRequest) (*UpdateWhitelistResponse, error)
	SubscribePlayerEvent(*SubscribePlayerEventRequest, MCManagement_SubscribePlayerEventServer) error
	GetResourceConsumption(context.Context, *GetResourceConsumptionRequest) (*GetResourceConsumptionResponse, error)
	SubscribeResourceConsumptionEvent(*SubscribeResourceConsumptionEventRequest, MCManagement_SubscribeResourceConsumptionEventServer) error
	SubscribeHeartbeat(*SubscribeHeartbeatRequest, MCManagement_SubscribeHeartbeatServer) error
	mustEmbedUnimplementedMCManagementServer()
}

// UnimplementedMCManagementServer must be embedded to have forward compatible implementations.
type UnimplementedMCManagementServer struct {
}

func (UnimplementedMCManagementServer) GetPlayerCount(context.Context, *GetPlayerCountRequest) (*GetPlayerCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPlayerCount not implemented")
}
func (UnimplementedMCManagementServer) SubscribePlayerCount(*SubscribePlayerCountRequest, MCManagement_SubscribePlayerCountServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribePlayerCount not implemented")
}
func (UnimplementedMCManagementServer) UpdateWhitelist(context.Context, *UpdateWhitelistRequest) (*UpdateWhitelistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWhitelist not implemented")
}
func (UnimplementedMCManagementServer) SubscribePlayerEvent(*SubscribePlayerEventRequest, MCManagement_SubscribePlayerEventServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribePlayerEvent not implemented")
}
func (UnimplementedMCManagementServer) GetResourceConsumption(context.Context, *GetResourceConsumptionRequest) (*GetResourceConsumptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResourceConsumption not implemented")
}
func (UnimplementedMCManagementServer) SubscribeResourceConsumptionEvent(*SubscribeResourceConsumptionEventRequest, MCManagement_SubscribeResourceConsumptionEventServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeResourceConsumptionEvent not implemented")
}
func (UnimplementedMCManagementServer) SubscribeHeartbeat(*SubscribeHeartbeatRequest, MCManagement_SubscribeHeartbeatServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeHeartbeat not implemented")
}
func (UnimplementedMCManagementServer) mustEmbedUnimplementedMCManagementServer() {}

// UnsafeMCManagementServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MCManagementServer will
// result in compilation errors.
type UnsafeMCManagementServer interface {
	mustEmbedUnimplementedMCManagementServer()
}

func RegisterMCManagementServer(s grpc.ServiceRegistrar, srv MCManagementServer) {
	s.RegisterService(&MCManagement_ServiceDesc, srv)
}

func _MCManagement_GetPlayerCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPlayerCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCManagementServer).GetPlayerCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MCManagement/GetPlayerCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCManagementServer).GetPlayerCount(ctx, req.(*GetPlayerCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCManagement_SubscribePlayerCount_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribePlayerCountRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MCManagementServer).SubscribePlayerCount(m, &mCManagementSubscribePlayerCountServer{stream})
}

type MCManagement_SubscribePlayerCountServer interface {
	Send(*SubscribePlayerCountResponse) error
	grpc.ServerStream
}

type mCManagementSubscribePlayerCountServer struct {
	grpc.ServerStream
}

func (x *mCManagementSubscribePlayerCountServer) Send(m *SubscribePlayerCountResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MCManagement_UpdateWhitelist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWhitelistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCManagementServer).UpdateWhitelist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MCManagement/UpdateWhitelist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCManagementServer).UpdateWhitelist(ctx, req.(*UpdateWhitelistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCManagement_SubscribePlayerEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribePlayerEventRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MCManagementServer).SubscribePlayerEvent(m, &mCManagementSubscribePlayerEventServer{stream})
}

type MCManagement_SubscribePlayerEventServer interface {
	Send(*SubscribePlayerEventResponse) error
	grpc.ServerStream
}

type mCManagementSubscribePlayerEventServer struct {
	grpc.ServerStream
}

func (x *mCManagementSubscribePlayerEventServer) Send(m *SubscribePlayerEventResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MCManagement_GetResourceConsumption_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetResourceConsumptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCManagementServer).GetResourceConsumption(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MCManagement/GetResourceConsumption",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCManagementServer).GetResourceConsumption(ctx, req.(*GetResourceConsumptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCManagement_SubscribeResourceConsumptionEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeResourceConsumptionEventRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MCManagementServer).SubscribeResourceConsumptionEvent(m, &mCManagementSubscribeResourceConsumptionEventServer{stream})
}

type MCManagement_SubscribeResourceConsumptionEventServer interface {
	Send(*SubscribeResourceConsumptionEventReponse) error
	grpc.ServerStream
}

type mCManagementSubscribeResourceConsumptionEventServer struct {
	grpc.ServerStream
}

func (x *mCManagementSubscribeResourceConsumptionEventServer) Send(m *SubscribeResourceConsumptionEventReponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MCManagement_SubscribeHeartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeHeartbeatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MCManagementServer).SubscribeHeartbeat(m, &mCManagementSubscribeHeartbeatServer{stream})
}

type MCManagement_SubscribeHeartbeatServer interface {
	Send(*SubscribeHeartbeatResponse) error
	grpc.ServerStream
}

type mCManagementSubscribeHeartbeatServer struct {
	grpc.ServerStream
}

func (x *mCManagementSubscribeHeartbeatServer) Send(m *SubscribeHeartbeatResponse) error {
	return x.ServerStream.SendMsg(m)
}

// MCManagement_ServiceDesc is the grpc.ServiceDesc for MCManagement service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MCManagement_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "MCManagement",
	HandlerType: (*MCManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPlayerCount",
			Handler:    _MCManagement_GetPlayerCount_Handler,
		},
		{
			MethodName: "UpdateWhitelist",
			Handler:    _MCManagement_UpdateWhitelist_Handler,
		},
		{
			MethodName: "GetResourceConsumption",
			Handler:    _MCManagement_GetResourceConsumption_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribePlayerCount",
			Handler:       _MCManagement_SubscribePlayerCount_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribePlayerEvent",
			Handler:       _MCManagement_SubscribePlayerEvent_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeResourceConsumptionEvent",
			Handler:       _MCManagement_SubscribeResourceConsumptionEvent_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeHeartbeat",
			Handler:       _MCManagement_SubscribeHeartbeat_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "discord-mc-protobuf/proto/mc-management.proto",
}
